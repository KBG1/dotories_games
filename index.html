<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>í•œì¤„ ë„ë„› ìŒ“ê¸°</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root {
    --bg:#fafafa;
    --fg:#2c3e50;
    --accent:#ff6b6b;
    --ok:#2ecc71;
  }
  html, body { height:100%; }
  body { margin:0; overflow:hidden; background:var(--bg); touch-action:none; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  canvas { display:block; }

  /* HUD */
  .hud {
    position:fixed; left:50%; top:14px; transform:translateX(-50%);
    display:flex; gap:16px; align-items:center;
    background:rgba(255,255,255,.95); padding:10px 16px; border-radius:16px;
    box-shadow:0 6px 20px rgba(0,0,0,.1);
    user-select:none; font-weight:600;
    border:1px solid rgba(255,255,255,.2);
  }
  .pill { 
    padding:6px 12px; border-radius:999px; background:#fff; 
    border:1px solid #eee; font-size:0.9rem;
    box-shadow:0 2px 8px rgba(0,0,0,.05);
  }
  .good { color:var(--ok); font-weight:700; }
  .bad { color:var(--accent); font-weight:700; }

  /* Messages */
  #messageWrap {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
  }
  #failMessage, #startMessage {
    display:none; text-align:center; pointer-events:auto;
    background:rgba(255,255,255,.98); padding:32px 36px; border-radius:20px; 
    box-shadow:0 15px 40px rgba(0,0,0,.15);
    border:1px solid rgba(255,255,255,.3);
    max-width:400px; margin:20px;
  }
  #failMessage h1, #startMessage h1 { margin:.2em 0; font-size:2.4rem; font-weight:700; }
  #failMessage p, #startMessage p { margin:.4em 0 1.5em; opacity:.8; line-height:1.5; }
  .btn {
    font-size:1.1rem; padding:.8em 1.6em; border-radius:14px; border:none; cursor:pointer;
    background:var(--fg); color:#fff; font-weight:600;
    transition:all 0.2s ease; box-shadow:0 4px 12px rgba(44,62,80,.3);
  }
  .btn:hover { transform:translateY(-2px); box-shadow:0 6px 16px rgba(44,62,80,.4); }
</style>
</head>
<body>
<div class="hud" id="hud">
  <span class="pill">ë†’ì´ <span id="score">0</span></span>
  <span class="pill">ìµœê³  <span id="best">0</span></span>
  <span class="pill">ì†ë„ <span id="speedDisp">8</span></span>
</div>

<div id="messageWrap">
  <div id="startMessage">
    <h1>ğŸ© í•œì¤„ ë„ë„› ìŒ“ê¸°</h1>
    <p>í™”ë©´ì„ <b>í´ë¦­</b>í•˜ë©´ ì´ë™ ì¤‘ì¸ ë„ë„›ì´ ë–¨ì–´ì§‘ë‹ˆë‹¤.<br/>ë„ë„›ì„ <b>í•œ ì¤„ë¡œ ë†’ì´ ìŒ“ì•„ì„œ</b> ìµœê³  ê¸°ë¡ì„ ì„¸ì›Œë³´ì„¸ìš”!</p>
    <button id="startButton" class="btn">ğŸ® ì‹œì‘í•˜ê¸°</button>
  </div>
  <div id="failMessage">
    <h1 class="bad">ğŸ’¥ ì‹¤íŒ¨!</h1>
    <p id="failReason">íƒ‘ì´ ë¬´ë„ˆì¡Œì–´ìš”.</p>
    <p style="font-size:0.9rem; opacity:0.7; margin-top:1em;">ìµœê³  ë†’ì´: <span id="bestInFail">0</span>ê°œ</p>
    <button id="resetButton" class="btn">ğŸ”„ ë‹¤ì‹œ ìŒ“ê¸°</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Body, Composite, Events } = Matter;

// ê²Œì„ ì„¤ì • - í™”ë©´ í¬ê¸°ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ê³„ì‚°
function getGameSettings() {
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const baseWidth = Math.min(screenWidth, screenHeight) * 0.12; // í™”ë©´ í¬ê¸°ì˜ 12%
  
  // í™”ë©´ ë„ˆë¹„ì— ë”°ë¥¸ ì†ë„ ì¡°ì • (í° í™”ë©´ì¼ìˆ˜ë¡ ë¹ ë¥´ê²Œ)
  const baseSpeed = Math.max(3, Math.min(8, screenWidth / 150)); // 3~8 ì‚¬ì´ë¡œ ì œí•œ
  
  // í™”ë©´ í¬ê¸°ì— ë”°ë¥¸ ë¬¼ë¦¬ ì„¤ì • (ì‘ì€ í™”ë©´ì¼ìˆ˜ë¡ ì•ˆì •ì ìœ¼ë¡œ)
  const sizeRatio = Math.min(screenWidth, screenHeight) / 800; // 800px ê¸°ì¤€
  const physicsScale = Math.max(0.5, Math.min(1.2, sizeRatio)); // 0.5~1.2 ë°°ìœ¨
  
  return {
    donut: {
      width: baseWidth,
      height: baseWidth * 0.5, // ê°€ë¡œ:ì„¸ë¡œ = 2:1 ë¹„ìœ¨
      tolerance: baseWidth * 0.6, // í—ˆìš© ë²”ìœ„
    },
    speed: {
      start: baseSpeed,
      increment: baseSpeed * 0.025, // ì‹œì‘ ì†ë„ì˜ 2.5%ì”© ì¦ê°€
    },
    physics: {
      gravity: 0.8 * physicsScale, // ì‘ì€ í™”ë©´ì¼ìˆ˜ë¡ ì•½í•œ ì¤‘ë ¥
      density: 0.0015 * physicsScale, // ì‘ì€ í™”ë©´ì¼ìˆ˜ë¡ ê°€ë²¼ì›€
      friction: Math.max(0.6, 0.7 + (1 - physicsScale) * 0.3), // ì‘ì€ í™”ë©´ì¼ìˆ˜ë¡ ë†’ì€ ë§ˆì°°ë ¥
      restitution: Math.max(0.05, 0.2 * physicsScale), // ì‘ì€ í™”ë©´ì¼ìˆ˜ë¡ ì ê²Œ íŠ•ê¹€
    }
  };
}

// ë¬¼ë¦¬ ì„¤ì •ì€ ë™ì ìœ¼ë¡œ ê³„ì‚°ë˜ë¯€ë¡œ ì œê±°
const ANGLE_LIMIT_DEG = 30;
// ì†ë„ëŠ” ë™ì ìœ¼ë¡œ ê³„ì‚°ë˜ë¯€ë¡œ ì œê±°
const DROP_COOLDOWN_MS = 800;
const STABLE_SPEED_EPS = 0.1;
const STABLE_ANGVEL_EPS = 0.01;
const DONUT_SPRITE_URL = "donut.png";

let engine, world, render, runner;
let ground, leftWall, rightWall;
let movingDonut = null;
let direction = 1;
let speed = getGameSettings().speed.start;

let stackCenterX = null;
let donutStack = [];
let gameOver = false;
let started = false;
let score = 0;
let best = Number(localStorage.getItem("donut_best") || 0);
let nextDonutReady = false;

// DOM
const $score = document.getElementById('score');
const $best = document.getElementById('best');
const $speedDisp = document.getElementById('speedDisp');
const $failMessage = document.getElementById('failMessage');
const $failReason = document.getElementById('failReason');
const $bestInFail = document.getElementById('bestInFail');
const $resetButton = document.getElementById('resetButton');
const $startMessage = document.getElementById('startMessage');
const $startButton = document.getElementById('startButton');

$best.textContent = best;
$speedDisp.textContent = speed.toFixed(1);

// ìœ í‹¸
const rad2deg = r => r * 180 / Math.PI;

// ì›”ë“œ/ë Œë” ìƒì„±
function createEngineAndRender() {
  engine = Engine.create();
  world = engine.world;
  
  const gameSettings = getGameSettings();
  engine.world.gravity.y = gameSettings.physics.gravity;
  engine.timing.timeScale = 1.0;

  render = Render.create({
    element: document.body,
    engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: '#f8f9fa',
      pixelRatio: Math.min(window.devicePixelRatio || 1, 2),
      showVelocity: false,
      showAngleIndicator: false,
      showCollisions: false
    }
  });
  Render.run(render);
  runner = Runner.create();
  Runner.run(runner, engine);

  setupBoundaries();
}

function setupBoundaries() {
  const w = window.innerWidth;
  const h = window.innerHeight;

  ground = Bodies.rectangle(w/2, h-18, w+200, 36, { 
    isStatic: true, 
    friction: 1.0,
    render:{ fillStyle: '#2c3e50' }
  });
  leftWall = Bodies.rectangle(-40, h/2, 80, h*2, { isStatic: true, render:{ visible:false }});
  rightWall = Bodies.rectangle(w+40, h/2, 80, h*2, { isStatic: true, render:{ visible:false }});
  Composite.add(world, [ground, leftWall, rightWall]);
}

// ë„ë„› ìƒì„±/ì´ë™/ë“œë¡­
function createMovingDonut() {
  if (movingDonut) return; // ì´ë¯¸ ìˆìœ¼ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ
  
  const w = window.innerWidth;
  const gameSettings = getGameSettings(); // ë™ì  ì„¤ì • ê³„ì‚°
  const donutSize = gameSettings.donut;
  const startX = Math.random() < 0.5 ? donutSize.width : w - donutSize.width;
  const startY = 80;

  const donut = Bodies.rectangle(startX, startY, donutSize.width, donutSize.height, {
    isStatic: true,
    density: gameSettings.physics.density,
    friction: gameSettings.physics.friction,
    restitution: gameSettings.physics.restitution,
    // inertia: Infinity, // íšŒì „ í—ˆìš©ìœ¼ë¡œ ë³€ê²½
    render: DONUT_SPRITE_URL ? {
      sprite: { 
        texture: DONUT_SPRITE_URL, 
        xScale: donutSize.width/200, 
        yScale: donutSize.height/200 
      }
    } : {
      fillStyle: '#f39c12', 
      strokeStyle: '#e67e22', 
      lineWidth: 3
    }
  });

  movingDonut = donut;
  Composite.add(world, donut);
  direction = (startX < window.innerWidth / 2) ? 1 : -1;
  nextDonutReady = true;
}

function dropDonut() {
  if (gameOver || !started || !movingDonut || !nextDonutReady) return;

  // ì²« ë²ˆì§¸ ë„ë„›ì´ë©´ ìŠ¤íƒ ì¤‘ì‹¬ ì„¤ì •
  if (stackCenterX === null) {
    stackCenterX = movingDonut.position.x;
  }

  // ë“œë¡­
  Body.setStatic(movingDonut, false);
  Body.setAngularVelocity(movingDonut, 0);
  Body.setAngle(movingDonut, 0);
  
  donutStack.push(movingDonut);
  movingDonut = null;
  nextDonutReady = false;
}

// ì‹¤íŒ¨/ì„±ê³µ íŒì •
function isSleeping(body) {
  return body && !body.isStatic &&
         Math.hypot(body.velocity.x, body.velocity.y) < STABLE_SPEED_EPS &&
         Math.abs(body.angularVelocity) < STABLE_ANGVEL_EPS;
}

function checkTowerStability() {
  if (donutStack.length === 0) return { stable: true };

  const donutSize = getGameSettings().donut; // ë™ì  í¬ê¸° ê°€ì ¸ì˜¤ê¸°

  for (let donut of donutStack) {
    if (!donut) continue;

    // ë°”ë‹¥ ë°–ìœ¼ë¡œ ì™„ì „íˆ ë–¨ì–´ì§„ ë„ë„›ë§Œ ì‹¤íŒ¨ ì²˜ë¦¬
    if (donut.position.y > window.innerHeight + donutSize.height * 2) {
      return { stable: false, reason: 'ë„ë„›íƒ‘ì´ ë¬´ë„ˆì¡Œì–´ìš”!' };
    }

    // ë„ë„›ì´ 2ê°œ ì´ìƒì¼ ë•Œë§Œ í•œ ì¤„ ì²´í¬ (ì²« ë„ë„›ì€ ì–´ë””ë“  OK)
    if (donutStack.length >= 2 && stackCenterX !== null) {
      const dx = Math.abs(donut.position.x - stackCenterX);
      if (dx > donutSize.tolerance * 1.5) { // ë” ê´€ëŒ€í•˜ê²Œ
        return { stable: false, reason: 'í•œ ì¤„ì—ì„œ ë²—ì–´ë‚¬ì–´ìš”!' };
      }
    }

    // ì™„ì „íˆ ë’¤ì§‘ì–´ì§„ ë„ë„›ë§Œ ì‹¤íŒ¨ (90ë„ ì´ìƒ)
    const angleDeg = Math.abs(rad2deg(donut.angle));
    if (angleDeg > 80) {
      return { stable: false, reason: 'ë„ë„›ì´ ë„˜ì–´ì¡Œì–´ìš”!' };
    }
  }
  
  return { stable: true };
}

function showFail(reasonText) {
  gameOver = true;
  $failReason.textContent = reasonText || 'íƒ‘ì´ ë¬´ë„ˆì¡Œì–´ìš”.';
  $bestInFail.textContent = best;
  $failMessage.style.display = 'block';
}

// ìŠ¤ì½”ì–´/ë‚œì´ë„
function onSuccessfulPlace() {
  score += 1;
  $score.textContent = score;
  if (score > best) {
    best = score;
    localStorage.setItem('donut_best', String(best));
    $best.textContent = best;
  }
  const gameSettings = getGameSettings();
  const maxSpeed = gameSettings.speed.start * 2.5; // ì‹œì‘ ì†ë„ì˜ 2.5ë°°ê¹Œì§€
  speed = Math.min(gameSettings.speed.start + score * gameSettings.speed.increment, maxSpeed);
  $speedDisp.textContent = speed.toFixed(1);
  
  // ì„±ê³µ ì‹œ ì‹œê°ì  í”¼ë“œë°±
  $score.style.color = 'var(--ok)';
  setTimeout(() => {
    $score.style.color = '';
  }, 300);
}

// ë£¨í”„ ì´ë²¤íŠ¸
function attachEngineEvents() {
  // ì¢Œìš° ì´ë™
  Events.on(engine, 'beforeUpdate', () => {
    if (gameOver) return;

    if (movingDonut && movingDonut.isStatic) {
      Body.translate(movingDonut, { x: speed * direction, y: 0 });

      const donutSize = getGameSettings().donut;
      const margin = donutSize.width / 2 + 10;
      if (movingDonut.position.x > window.innerWidth - margin || movingDonut.position.x < margin) {
        direction *= -1;
      }
    }
    
    // íšŒì „ ì œì–´ (ë„ˆë¬´ ê°•í•˜ì§€ ì•Šê²Œ)
    donutStack.forEach(donut => {
      if (donut && !donut.isStatic) {
        // íšŒì „ ì†ë„ë§Œ ì¤„ì´ê³ , ê°ë„ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ ìœ ì§€
        if (Math.abs(donut.angularVelocity) > 0.1) {
          Body.setAngularVelocity(donut, donut.angularVelocity * 0.8);
        }
      }
    });
  });

  // ì•ˆì •í™” ë° ì‹¤íŒ¨ íŒì •
  Events.on(engine, 'afterUpdate', () => {
    if (gameOver) return;

    // íƒ€ì›Œ ì•ˆì •ì„± ì²´í¬
    const stability = checkTowerStability();
    if (!stability.stable) {
      showFail(stability.reason);
      return;
    }

    // ì•ˆì •í™” ì²´í¬
    for (let donut of donutStack) {
      if (!donut || donut.isStatic) continue;

      if (isSleeping(donut)) {
        if (!donut.hasScored) {
          donut.hasScored = true;
          onSuccessfulPlace();
          
          // ë‹¤ìŒ ë„ë„› ìƒì„±
          setTimeout(() => {
            if (!gameOver) createMovingDonut();
          }, DROP_COOLDOWN_MS);
        }
      }
    }
  });
}

// ì‹œì‘/ë¦¬ì…‹/ì…ë ¥
function startGame() {
  if (started) return;
  started = true;
  gameOver = false;
  score = 0;
  speed = getGameSettings().speed.start;
  donutStack = [];
  stackCenterX = null;
  nextDonutReady = false;
  
  $score.textContent = score;
  $speedDisp.textContent = speed.toFixed(1);
  $startMessage.style.display = 'none';
  $failMessage.style.display = 'none';

  createMovingDonut();
}

function resetGame() {
  try {
    Render.stop(render);
    Runner.stop(runner);
    render.canvas.remove();
    render.textures = {};
  } catch(e){}

  Composite.clear(engine.world, false);
  engine.events = {};

  donutStack = [];
  stackCenterX = null;
  movingDonut = null;
  started = false;
  gameOver = false;
  speed = getGameSettings().speed.start;
  nextDonutReady = false;
  
  $score.textContent = '0';
  $speedDisp.textContent = speed.toFixed(1);

  createEngineAndRender();
  attachEngineEvents();

  $failMessage.style.display = 'none';
  $startMessage.style.display = 'block';
}

function handleClick() {
  if (!started) {
    startGame();
  } else {
    dropDonut();
  }
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
window.addEventListener('click', handleClick);
$startButton.addEventListener('click', (e) => {
  e.stopPropagation();
  startGame();
});
$resetButton.addEventListener('click', resetGame);

// ë¦¬ì‚¬ì´ì¦ˆ
function onResize() {
  if (!render) return;
  const w = window.innerWidth, h = window.innerHeight;
  render.canvas.width = w;
  render.canvas.height = h;
  render.options.width = w;
  render.options.height = h;

  Body.setPosition(ground, { x: w/2, y: h - 18 });
  Body.setVertices(ground, Bodies.rectangle(w/2, h-18, w+200, 36).vertices);
  Body.setPosition(leftWall, { x:-40, y:h/2 });
  Body.setPosition(rightWall, { x:w+40, y:h/2 });
}
window.addEventListener('resize', onResize);

// ë¶€íŠ¸ìŠ¤íŠ¸ë©
createEngineAndRender();
attachEngineEvents();
$startMessage.style.display = 'block';

</script>
</body>
</html>