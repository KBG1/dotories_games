"use client";

import React, { useState, useEffect } from "react";

function GamePage() {
  return <FlowFreeGame onBack={() => window.history.back()} />;
}

// Í≤åÏûÑ ÌÉÄÏûÖ Ï†ïÏùò
type CellType = "empty" | "dot" | "path";
type Color = "red" | "blue" | "green" | "yellow" | "purple" | "orange";

interface GameCell {
  type: CellType;
  color?: Color;
  connections?: {
    top?: boolean;
    right?: boolean;
    bottom?: boolean;
    left?: boolean;
  };
}

interface PuzzleData {
  grid: GameCell[][];
  pairs: Array<{ color: Color; dots: Array<[number, number]> }>;
}

interface PuzzleConfig {
  puzzle_id: number;
  size: number;
  colors: Array<{
    color: Color;
    start_x: number;
    start_y: number;
    end_x: number;
    end_y: number;
  }>;
}

// JSONÏóêÏÑú ÌçºÏ¶ê ÏÉùÏÑ±
function generateFlowFreePuzzleFromConfig(config: PuzzleConfig): PuzzleData {
  const grid: GameCell[][] = Array(config.size)
    .fill(null)
    .map(() =>
      Array(config.size)
        .fill(null)
        .map(() => ({ type: "empty" as CellType }))
    );

  const pairs: Array<{ color: Color; dots: Array<[number, number]> }> = [];

  // Í∞Å ÏÉâÏÉÅÏùò ÏãúÏûëÏ†êÍ≥º ÎÅùÏ†êÏùÑ Î∞∞Ïπò
  config.colors.forEach(({ color, start_x, start_y, end_x, end_y }) => {
    const dots: Array<[number, number]> = [
      [start_y, start_x], // ÏãúÏûëÏ†ê (y, x ÏàúÏÑú)
      [end_y, end_x]      // ÎÅùÏ†ê (y, x ÏàúÏÑú)
    ];
    
    pairs.push({ color, dots });
    
    // Ï†êÎì§ÏùÑ Í∑∏Î¶¨ÎìúÏóê Î∞∞Ïπò
    dots.forEach(([row, col]) => {
      grid[row][col] = { type: "dot", color };
    });
  });

  return { grid, pairs };
}

// Flow Free Í≤åÏûÑ Ïª¥Ìè¨ÎÑåÌä∏
function FlowFreeGame({ onBack }: { onBack: () => void }) {
  const [puzzles, setPuzzles] = useState<PuzzleConfig[]>([]);
  const [currentPuzzle, setCurrentPuzzle] = useState<PuzzleConfig | null>(null);
  const [puzzleData, setPuzzleData] = useState<PuzzleData | null>(null);
  const [gameGrid, setGameGrid] = useState<GameCell[][]>([]);
  const [loading, setLoading] = useState(true);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentColor, setCurrentColor] = useState<Color | null>(null);
  const [currentPath, setCurrentPath] = useState<Array<[number, number]>>([]);
  const [startTime] = useState<number>(Date.now());
  const [currentTime, setCurrentTime] = useState<number>(0);
  const [gameCompleted, setGameCompleted] = useState(false);
  const [completionTime, setCompletionTime] = useState<number>(0);
  const [completionPercent, setCompletionPercent] = useState<number>(0);

  // ÌçºÏ¶ê Î°úÎìú
  useEffect(() => {
    fetch('/flow_free_puzzles.json')
      .then(response => response.json())
      .then((data: PuzzleConfig[]) => {
        setPuzzles(data);
        // ÎûúÎç§ ÌçºÏ¶ê ÏÑ†ÌÉù
        const randomPuzzle = data[Math.floor(Math.random() * data.length)];
        setCurrentPuzzle(randomPuzzle);
        const puzzle = generateFlowFreePuzzleFromConfig(randomPuzzle);
        setPuzzleData(puzzle);
        setGameGrid(puzzle.grid);
        setLoading(false);
      })
      .catch(error => {
        console.error('ÌçºÏ¶ê Î°úÎî© Ïã§Ìå®:', error);
        setLoading(false);
      });
  }, []);

  // ÏôÑÏÑ±ÎèÑ Í≥ÑÏÇ∞ (Ï±ÑÏõåÏßÑ Ïπ∏ Í∏∞Ï§Ä) - useCallbackÏúºÎ°ú ÏµúÏ†ÅÌôî
  const updateCompletionPercent = React.useCallback(() => {
    if (!currentPuzzle) return;
    const totalCells = currentPuzzle.size * currentPuzzle.size;
    const filledCells = gameGrid
      .flat()
      .filter((cell) => cell.type === "dot" || cell.type === "path").length;
    setCompletionPercent(Math.round((filledCells / totalCells) * 100));
  }, [currentPuzzle, gameGrid]);
  // Ïã§ÏãúÍ∞Ñ ÌÉÄÏù¥Î®∏
  useEffect(() => {
    if (!gameCompleted) {
      const timer = setInterval(() => {
        setCurrentTime(Math.floor((Date.now() - startTime) / 1000));
        updateCompletionPercent();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [startTime, gameCompleted, gameGrid, updateCompletionPercent]);

  // ÌÑ∞Ïπò Ïä§ÌÅ¨Î°§ Î∞©ÏßÄÎ•º ÏúÑÌïú non-passive Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
  useEffect(() => {
    const preventDefault = (e: Event) => {
      if (isDrawing) {
        e.preventDefault();
      }
    };

    // Í≤åÏûÑ ÏòÅÏó≠ÏóêÏÑúÎßå ÌÑ∞Ïπò Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ
    document.addEventListener('touchmove', preventDefault, { passive: false });
    document.addEventListener('touchstart', preventDefault, { passive: false });

    return () => {
      document.removeEventListener('touchmove', preventDefault);
      document.removeEventListener('touchstart', preventDefault);
    };
  }, [isDrawing]);

  // Ïù∏Ï†ë ÏÖÄ Ï≤¥ÌÅ¨
  const isAdjacent = React.useCallback((
    [r1, c1]: [number, number],
    [r2, c2]: [number, number]
  ): boolean => {
    return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
  }, []);

  // Ïù∏Ï†ë ÏÖÄ Í∞ÄÏ†∏Ïò§Í∏∞
  const getAdjacentCells = React.useCallback((
    row: number,
    col: number
  ): Array<[number, number]> => {
    if (!currentPuzzle) return [];
    return [
      [row - 1, col],
      [row + 1, col],
      [row, col - 1],
      [row, col + 1],
    ].filter(([r, c]) => r >= 0 && r < currentPuzzle.size && c >= 0 && c < currentPuzzle.size) as Array<
      [number, number]
    >;
  }, [currentPuzzle]);

  // Í≤ΩÎ°ú Ïó∞Í≤∞ ÌôïÏù∏ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
  const isPathConnected = React.useCallback((
    dot1: [number, number],
    dot2: [number, number],
    color: Color
  ): boolean => {
    const [r1, c1] = dot1;
    const [r2, c2] = dot2;

    // Í∞Å Ï†ê Ï£ºÎ≥ÄÏóê Í∞ôÏùÄ ÏÉâ Í≤ΩÎ°úÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    const hasPath1 = getAdjacentCells(r1, c1).some(
      ([r, c]) =>
        gameGrid[r][c].type === "path" && gameGrid[r][c].color === color
    );

    const hasPath2 = getAdjacentCells(r2, c2).some(
      ([r, c]) =>
        gameGrid[r][c].type === "path" && gameGrid[r][c].color === color
    );

    return hasPath1 && hasPath2;
  }, [gameGrid, getAdjacentCells]);

  // Í≤åÏûÑ ÏôÑÎ£å Ï≤¥ÌÅ¨
  const checkGameCompletion = React.useCallback(() => {
    if (!puzzleData || !currentPuzzle) return;
    
    console.log("Í≤åÏûÑ ÏôÑÎ£å Ï≤¥ÌÅ¨ Ï§ë...");

    // Î™®Îì† ÌéòÏñ¥Í∞Ä Ïó∞Í≤∞ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
    const connectedCount = puzzleData.pairs.filter((pair) => {
      const [dot1, dot2] = pair.dots;
      const connected = isPathConnected(dot1, dot2, pair.color);
      console.log(`${pair.color} Ïó∞Í≤∞ ÏÉÅÌÉú:`, connected);
      return connected;
    }).length;

    console.log(`Ïó∞Í≤∞Îêú ÌéòÏñ¥: ${connectedCount}/${puzzleData.pairs.length}`);

    // Î™®Îì† ÏÖÄÏù¥ Ï±ÑÏõåÏ°åÎäîÏßÄ ÌôïÏù∏ (Flow FreeÏùò ÌïµÏã¨ Í∑úÏπô)
    const totalCells = currentPuzzle.size * currentPuzzle.size;
    const filledCells = gameGrid.flat().filter(cell => cell.type !== "empty").length;
    console.log(`Ï±ÑÏõåÏßÑ Ïπ∏: ${filledCells}/${totalCells}`);

    const allConnected = connectedCount === puzzleData.pairs.length;
    const allFilled = filledCells === totalCells;

    console.log("Î™®Îì† ÌéòÏñ¥ Ïó∞Í≤∞:", allConnected);
    console.log("Î™®Îì† Ïπ∏ Ï±ÑÏõÄ:", allFilled);

    if (allConnected && allFilled) {
      console.log("üéâ Í≤åÏûÑ ÏôÑÎ£å!");
      setCompletionTime(currentTime);
      setGameCompleted(true);
    }
  }, [puzzleData, currentPuzzle, gameGrid, currentTime, isPathConnected]);

  // handleMoveÎ•º useCallbackÏúºÎ°ú ÏµúÏ†ÅÌôî
  const handleMove = React.useCallback((row: number, col: number) => {
    if (!isDrawing || !currentColor) return;

    const cell = gameGrid[row][col];

    // Í∞ôÏùÄ ÏÉâÏÉÅÏùò Îã§Î•∏ Ï†êÏóê ÎèÑÎã¨ (Ïó∞Í≤∞ ÏôÑÏÑ±)
    if (cell.type === "dot" && cell.color === currentColor) {
      const startPos = currentPath[0];
      if (startPos && (startPos[0] !== row || startPos[1] !== col)) {
        // Í≤ΩÎ°ú ÏôÑÏÑ±
        setIsDrawing(false);
        setCurrentColor(null);
        setCurrentPath([]);
        // ÏôÑÎ£å Ï≤¥ÌÅ¨Î•º ÏïΩÍ∞Ñ ÏßÄÏó∞ÏãúÏºúÏÑú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ Ïã§Ìñâ
        setTimeout(() => {
          checkGameCompletion();
        }, 100);
        return;
      }
    }

    // Îã§Î•∏ ÏÉâÏÉÅÏùò Ï†êÏù¥ÎÇò Í≤ΩÎ°úÎ•º ÏßÄÎÇòÎäî Í≤ΩÏö∞ Ï∞®Îã®
    if (
      (cell.type === "dot" && cell.color !== currentColor) ||
      (cell.type === "path" && cell.color !== currentColor)
    ) {
      return;
    }

    // Îπà Ïπ∏Ïù¥Í±∞ÎÇò Í∞ôÏùÄ ÏÉâ Í≤ΩÎ°úÏù∏ Í≤ΩÏö∞
    if (
      cell.type === "empty" ||
      (cell.type === "path" && cell.color === currentColor)
    ) {
      // Ïù∏Ï†ëÌïú ÏÖÄÏù∏ÏßÄ ÌôïÏù∏
      const lastPos = currentPath[currentPath.length - 1];
      if (lastPos && isAdjacent(lastPos, [row, col])) {
        // ÎêòÎèåÏïÑÍ∞ÄÍ∏∞ Ï≤¥ÌÅ¨
        if (currentPath.length > 1) {
          const prevPos = currentPath[currentPath.length - 2];
          if (prevPos[0] === row && prevPos[1] === col) {
            // ÎêòÎèåÏïÑÍ∞ÄÍ∏∞
            const newGrid = [...gameGrid];
            newGrid[lastPos[0]][lastPos[1]] = { type: "empty" };
            setGameGrid(newGrid);
            setCurrentPath((prev) => prev.slice(0, -1));
            return;
          }
        }

        // ÏÉà Í≤ΩÎ°ú Ï∂îÍ∞Ä
        if (!currentPath.some(([r, c]) => r === row && c === col)) {
          const newGrid = [...gameGrid];
          newGrid[row][col] = { type: "path", color: currentColor };
          setGameGrid(newGrid);
          setCurrentPath((prev) => [...prev, [row, col]]);
        }
      }
    }
  }, [isDrawing, currentColor, gameGrid, currentPath, checkGameCompletion, isAdjacent]);

  // ÏÉâÏÉÅ Îß§Ìïë
  const getColorClass = (color: Color): string => {
    const colorMap = {
      red: "bg-red-500",
      blue: "bg-blue-500",
      green: "bg-green-500",
      yellow: "bg-yellow-400",
      purple: "bg-purple-500",
      orange: "bg-orange-500",
    };
    return colorMap[color];
  };

  // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏Î•º ÏúÑÌïú Ï¢åÌëú Í≥ÑÏÇ∞ (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
  const getTouchCellPosition = React.useCallback((touch: React.Touch, gridElement: HTMLElement): [number, number] | null => {
    const rect = gridElement.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    // Ìå®Îî© Ï†úÍ±∞ (24px = 6 * 4px)
    const padding = 24;
    const adjustedX = x - padding;
    const adjustedY = y - padding;

    if (adjustedX < 0 || adjustedY < 0) return null;

    // ÏÖÄ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (72px + 4px gap) - w-18 h-18Î°ú Î≥ÄÍ≤Ω
    const cellSize = 76; // w-18 h-18 + gap-1
    const col = Math.floor(adjustedX / cellSize);
    const row = Math.floor(adjustedY / cellSize);

    if (currentPuzzle && row >= 0 && row < currentPuzzle.size && col >= 0 && col < currentPuzzle.size) {
      return [row, col];
    }
    return null;
  }, [currentPuzzle]);

  // ÌÑ∞Ïπò Í∞êÎèÑ Ìñ•ÏÉÅÏùÑ ÏúÑÌïú Ï∂îÍ∞Ä Ï≤òÎ¶¨
  useEffect(() => {
    let lastTouchTime = 0;

    const handleGlobalTouchMove = (e: TouchEvent) => {
      if (!isDrawing || e.touches.length === 0) return;

      // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ Ïä§Î°úÌãÄÎßÅ (60fps)
      const now = Date.now();
      if (now - lastTouchTime < 16) return;
      lastTouchTime = now;

      const touch = e.touches[0];
      const gameGrid = document.querySelector('[data-game-grid]') as HTMLElement;
      if (gameGrid) {
        const position = getTouchCellPosition(touch, gameGrid);
        if (position) {
          const [row, col] = position;
          handleMove(row, col);
        }
      }
    };

    if (isDrawing) {
      document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
    }

    return () => {
      document.removeEventListener('touchmove', handleGlobalTouchMove);
    };
  }, [isDrawing, getTouchCellPosition, handleMove]);

  // ÎìúÎûòÍ∑∏ ÏãúÏûë (ÎßàÏö∞Ïä§ + ÌÑ∞Ïπò)
  const handleStart = (row: number, col: number) => {
    const cell = gameGrid[row][col];

    if (cell.type === "dot" && cell.color) {
      // Í∏∞Ï°¥ Í≤ΩÎ°ú ÏßÄÏö∞Í∏∞
      clearPathsForColor(cell.color);

      setIsDrawing(true);
      setCurrentColor(cell.color);
      setCurrentPath([[row, col]]);
    }
  };

  const handleMouseDown = (row: number, col: number) => {
    handleStart(row, col);
  };

  const handleTouchStart = (row: number, col: number) => {
    handleStart(row, col);
  };

  // ÌäπÏ†ï ÏÉâÏÉÅÏùò Î™®Îì† Í≤ΩÎ°ú ÏßÄÏö∞Í∏∞
  const clearPathsForColor = (color: Color) => {
    const newGrid = gameGrid.map((row) =>
      row.map((cell) => {
        if (cell.type === "path" && cell.color === color) {
          return { type: "empty" as CellType };
        }
        return cell;
      })
    );
    setGameGrid(newGrid);
  };

  // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏
  const handleMouseEnter = (row: number, col: number) => {
    handleMove(row, col);
  };

  // Ïó∞ÏÜçÏ†ÅÏù∏ Í≤ΩÎ°ú Í∑∏Î¶¨Í∏∞Î•º ÏúÑÌïú Ï§ëÍ∞ÑÏ†ê Í≥ÑÏÇ∞
  const fillIntermediateCells = (start: [number, number], end: [number, number]) => {
    const [startRow, startCol] = start;
    const [endRow, endCol] = end;
    const cells: Array<[number, number]> = [];
    
    // Î∏åÎ†àÏ††ÌñÑ ÏßÅÏÑ† ÏïåÍ≥†Î¶¨Ï¶òÏùò Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ
    const dx = Math.abs(endCol - startCol);
    const dy = Math.abs(endRow - startRow);
    const sx = startCol < endCol ? 1 : -1;
    const sy = startRow < endRow ? 1 : -1;
    let err = dx - dy;
    
    let x = startCol;
    let y = startRow;
    
    while (true) {
      cells.push([y, x]);
      
      if (x === endCol && y === endRow) break;
      
      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x += sx;
      }
      if (e2 < dx) {
        err += dx;
        y += sy;
      }
    }
    
    return cells;
  };

  // ÌÑ∞Ïπò Î¨¥Î∏å Ïù¥Î≤§Ìä∏ (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
  const handleTouchMove = (e: React.TouchEvent) => {
    if (!isDrawing || e.touches.length === 0 || !currentColor) return;
    
    const touch = e.touches[0];
    const gridElement = e.currentTarget as HTMLElement;
    const position = getTouchCellPosition(touch, gridElement);
    
    if (position) {
      const [row, col] = position;
      const lastPos = currentPath[currentPath.length - 1];
      
      if (lastPos) {
        // ÎßàÏßÄÎßâ ÏúÑÏπòÏôÄ ÌòÑÏû¨ ÏúÑÏπò ÏÇ¨Ïù¥Ïùò Î™®Îì† ÏÖÄÎì§ÏùÑ Ï±ÑÏõÄ
        const intermediateCells = fillIntermediateCells(lastPos, [row, col]);
        
        for (const [r, c] of intermediateCells) {
          if (currentPuzzle && r >= 0 && r < currentPuzzle.size && c >= 0 && c < currentPuzzle.size) {
            const cell = gameGrid[r][c];
            
            // Ïú†Ìö®Ìïú Í≤ΩÎ°úÏù∏ÏßÄ ÌôïÏù∏
            if (cell.type === "empty" || 
                (cell.type === "path" && cell.color === currentColor) ||
                (cell.type === "dot" && cell.color === currentColor)) {
              
              // Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä (Ï§ëÎ≥µ Ï≤¥ÌÅ¨)
              if (!currentPath.some(([pr, pc]) => pr === r && pc === c)) {
                handleMove(r, c);
              }
            }
          }
        }
      } else {
        handleMove(row, col);
      }
    }
  };

  // ÎìúÎûòÍ∑∏ ÎÅù Í≥µÌÜµ Î°úÏßÅ
  const handleEnd = () => {
    setIsDrawing(false);
    setCurrentColor(null);
    setCurrentPath([]);
  };

  // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏
  const handleMouseUp = () => {
    handleEnd();
  };

  // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏
  const handleTouchEnd = () => {
    handleEnd();
  };

  // Í≤åÏûÑ ÏôÑÎ£å ÌôîÎ©¥
  if (gameCompleted) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border border-gray-600 max-w-md">
          <h2 className="text-3xl font-bold text-green-400 mb-4">
            üéâ Perfect!
          </h2>
          <p className="text-lg mb-4 text-gray-300">FlowÎ•º ÏôÑÏÑ±ÌñàÏäµÎãàÎã§!</p>
          <div className="text-xl font-semibold mb-6 text-white space-y-2">
            <p>
              ÏôÑÎ£å ÏãúÍ∞Ñ:{" "}
              <span className="text-yellow-400">{completionTime}Ï¥à</span>
            </p>
            <p>
              ÏôÑÏÑ±ÎèÑ: <span className="text-green-400">100%</span>
            </p>
          </div>
          <div className="space-y-4">
            <button
              onClick={() => {
                // ÏÉàÎ°úÏö¥ ÎûúÎç§ ÌçºÏ¶ê ÏÉùÏÑ±
                if (puzzles.length > 0) {
                  const randomPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                  setCurrentPuzzle(randomPuzzle);
                  const puzzle = generateFlowFreePuzzleFromConfig(randomPuzzle);
                  setPuzzleData(puzzle);
                  setGameGrid(puzzle.grid);
                  setGameCompleted(false);
                  setIsDrawing(false);
                  setCurrentColor(null);
                  setCurrentPath([]);
                }
              }}
              className="block w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 border border-blue-500 transition-colors"
            >
              ÏÉà ÌçºÏ¶ê
            </button>
            <button
              onClick={onBack}
              className="block w-full px-6 py-3 bg-gray-700 text-white rounded-lg hover:bg-gray-600 border border-gray-600 transition-colors"
            >
              ÌôàÏúºÎ°ú
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Î°úÎî© ÌôîÎ©¥
  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold mb-8 text-white">üåä Flow Free</h1>
          <p className="text-lg text-gray-300">ÌçºÏ¶êÏùÑ Î°úÎî© Ï§ë...</p>
        </div>
      </div>
    );
  }

  // ÌçºÏ¶êÏù¥ Î°úÎìúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
  if (!currentPuzzle || !puzzleData) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold mb-8 text-white">üåä Flow Free</h1>
          <p className="text-lg text-gray-300 mb-4">ÌçºÏ¶êÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§.</p>
          <button
            onClick={() => window.location.reload()}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            Îã§Ïãú ÏãúÎèÑ
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 p-4" style={{ 
      touchAction: "none", 
      overscrollBehavior: "none",
      userSelect: "none" 
    }}>
        <div className="max-w-4xl mx-auto">
        {/* Ìó§Îçî */}
        <div className="flex justify-between items-center mb-6">
          <button
            onClick={onBack}
            className="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600 transition-colors"
          >
            ‚Üê Îí§Î°ú
          </button>
          <h1 className="text-2xl font-bold text-white">
            Flow Free {currentPuzzle?.size}x{currentPuzzle?.size}
          </h1>
          <div className="text-right">
            <div className="text-lg font-semibold text-gray-300">
              {currentTime}Ï¥à
            </div>
            <div className="text-sm text-gray-400">{completionPercent}%</div>
          </div>
        </div>

        {/* Í≤åÏûÑ ÏÑ§Î™Ö */}
        <div className="bg-gray-800 p-4 rounded-lg shadow mb-6 border border-gray-600">
          <p className="text-gray-300 text-center">
            Í∞ôÏùÄ ÏÉâÍπîÏùò Ï†êÎì§ÏùÑ Ïó∞Í≤∞Ìï¥ÏÑú Î™®Îì† Ïπ∏ÏùÑ Ï±ÑÏö∞ÏÑ∏Ïöî! ÏÑ†Îì§Ïù¥ ÍµêÏ∞®ÌïòÎ©¥ Ïïà
            Îê©ÎãàÎã§.
          </p>
        </div>

        {/* Í≤åÏûÑ Í∑∏Î¶¨Îìú */}
        <div className="flex justify-center">
          <div
            className="grid gap-1 bg-gray-700 p-6 rounded-lg border border-gray-600"
            data-game-grid
            style={{
              gridTemplateColumns: `repeat(${currentPuzzle?.size || 5}, 1fr)`,
              width: "fit-content",
              touchAction: "none", // ÌÑ∞Ïπò Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ
            }}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp} // Í∑∏Î¶¨Îìú Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            {gameGrid.map((row, rowIndex) =>
              row.map((cell, colIndex) => (
                <div
                  key={`${rowIndex}-${colIndex}`}
                  className={`
                    w-18 h-18 border border-gray-600 cursor-pointer transition-all duration-150 select-none
                    ${cell.type === "empty" ? "bg-black hover:bg-gray-800" : ""}
                    ${
                      cell.type === "dot"
                        ? `${
                            cell.color ? getColorClass(cell.color) : ""
                          } border-gray-500`
                        : ""
                    }
                    ${
                      cell.type === "path"
                        ? `${cell.color ? getColorClass(cell.color) : ""}`
                        : ""
                    }
                    ${isDrawing && currentColor ? "hover:scale-105" : ""}
                  `}
                  onMouseDown={() => handleMouseDown(rowIndex, colIndex)}
                  onMouseEnter={() => handleMouseEnter(rowIndex, colIndex)}
                  onMouseUp={handleMouseUp}
                  onDragStart={(e) => e.preventDefault()}
                  onTouchStart={() => handleTouchStart(rowIndex, colIndex)}
                  onTouchEnd={handleTouchEnd}
                >
                  {cell.type === "dot" && (
                    <div className="w-full h-full flex items-center justify-center">
                      <div className="w-6 h-6 rounded-full bg-white border-2 border-gray-800 shadow-lg" />
                    </div>
                  )}
                </div>
              ))
            )}
          </div>
        </div>

        {/* ÏÉÅÌÉú ÌëúÏãú */}
        {isDrawing && currentColor && (
          <div className="text-center mt-6">
            <p className="text-lg font-semibold animate-pulse text-white">
              üéØ Ïó∞Í≤∞ Ï§ë:
              <span
                className={`ml-2 px-3 py-1 rounded text-white ${getColorClass(
                  currentColor
                )}`}
              >
                {currentColor}
              </span>
            </p>
          </div>
        )}

        {/* Î¶¨ÏÖã Î≤ÑÌäº */}
        <div className="text-center mt-6 space-x-4">
          <button
            onClick={() => {
              if (puzzleData) {
                setGameGrid(puzzleData.grid);
                setIsDrawing(false);
                setCurrentColor(null);
                setCurrentPath([]);
              }
            }}
            className="px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors border border-gray-500"
          >
            ÌòÑÏû¨ ÌçºÏ¶ê Î¶¨ÏÖã
          </button>
          
          <button
            onClick={() => {
              if (puzzles.length > 0) {
                const randomPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                setCurrentPuzzle(randomPuzzle);
                const puzzle = generateFlowFreePuzzleFromConfig(randomPuzzle);
                setPuzzleData(puzzle);
                setGameGrid(puzzle.grid);
                setIsDrawing(false);
                setCurrentColor(null);
                setCurrentPath([]);
              }
            }}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors border border-blue-500"
          >
            ÏÉà ÎûúÎç§ ÌçºÏ¶ê
          </button>
          
          <button
            onClick={() => {
              console.log("ÏàòÎèô ÏôÑÎ£å Ï≤¥ÌÅ¨ Ïã§Ìñâ");
              checkGameCompletion();
            }}
            className="px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors border border-purple-500"
          >
            ÏôÑÎ£å Ï≤¥ÌÅ¨ ÌÖåÏä§Ìä∏
          </button>
        </div>
      </div>
    </div>
  );
}

export default GamePage;
